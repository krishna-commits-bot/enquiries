Day 1 – Setup, Learning Basics
Install SQLite CLI & DB Browser.
Learn basic SQL commands: CREATE, INSERT, SELECT, UPDATE, DELETE.
Create sample HR database (tables: employees, roles, attendance).
Document:
What is SQLite?
When and why to use SQLite?
Advantages & disadvantages.
FAQs: concurrency, file-based DBs, locking, performance, security.
Day 2 – Schema Design & Queries
Design normalized schema.
Implement constraints: PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL.
Use indexes to improve performance.
Execute JOINs, aggregate queries, subqueries.
Document:
Schema decisions.
Query performance.
Index impact.
Transactions & locks.
Day 3 – Advanced Topics & Integration
Use transactions: BEGIN, COMMIT, ROLLBACK.
Simulate concurrency scenarios.
Explore Full-Text Search (FTS).
Try integrating with a Node.js/Python script.
Document:
Concurrency limitations.
FTS use cases.
Integration steps and challenges.
Day 4 – Use Case Demo & Summary
Create a CLI app using SQLite.
Stress-test with 100k+ rows.
Document:
Final schema design.
Q&A (~50 developer questions).
Performance metrics.
Backups, limitations, lessons learned.